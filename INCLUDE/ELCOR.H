/* ELCOR.H
by Paul S. Hirose, 1990 Sep 30
Declarations & definitions for globals in the ELCOR program.
*/

/* If MAIN is defined, this header will generate definitions.  Otherwise,
only declarations will be generated. */

#ifdef MAIN      /* generate DEFINITIONS */
#define CLASS
#define EQUALS(N) = N
#define DRIVER
#else         /* generate DECLARATIONS */
#define CLASS extern
#define EQUALS(N)
#endif

/*##################### MISC DEPENDENCIES #####################*/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>

/* POW(x, y) raises x to the y power.  Both args are type double. */
#define POW(x, y) pow(x, y)

/* VOIDP is the type of arg required by free().  Traditionally, this is a
char pointer.
typedef void *VOIDP;   <- use this for ANSI C
*/

typedef char *VOIDP;

/* size_t is the type of size argument passed to alloc(), calloc(), etc.  It
is also the type created by "sizeof".  ANSI C has a header containing a
typedef for size_t. */

/* typedef unsigned size_t; */

#define LBLLEN 40  /* maximum size of an observation label (getobs) */

/* Adjusts the code to the particular model in use.  At present, only SGP4 is
available. */
#define GP4 1

#if GP4
#define NUMEL 7      /* number of orbital elements */
#endif

#define MAXSITES 50
#define MAXOBS 100

#define min_val(x, y) ((x < y) ? (x) : (y))

/*##################### MATHEMATICAL CONSTANTS #####################*/


CLASS double
   one EQUALS(1.),
   pi EQUALS(3.141592653589793238462643383279502884197),
   twopi EQUALS(2*pi),
   de2ra EQUALS(pi/180.),   /* radians per degree */
   ra2de EQUALS(180/pi),    /* deg per radian */
   nocon EQUALS(twopi/1440.),
   d1con EQUALS(nocon/1440.),
   d2con EQUALS(d1con/1440.);


/*####################### PHYSICAL CONSTANTS #######################*/

/* dimensions & gravity of earth, World Geodetic System 1972 values */

CLASS double
xj3 EQUALS(-.253881e-5),
ck2 EQUALS(5.413079E-4),    /* .5 * xj2 */
ck4 EQUALS(6.2098875E-7),   /* -.375 * xj4 */
xke EQUALS(0.0743669161331734132),   /* = (G*M)^(1/2)*(er/min)^(3/2) where G =
            Newton's grav const, M = earth mass */

xkmper EQUALS(6378.135),   /* equatorial earth radius, km */

/* SGP4/SGP8 density constants.  qoms2t = ((qo - so) / xkmper) ** 4,
s = 1 + so / xkmper, where qo = 120 and so = 78 */

qoms2t EQUALS(1.880279159015270643865e-9),
s EQUALS(1.0122292801892716);

/* time units/day */
#define xmnpda 1440.0


/*####################### UNITS & CONVENTIONS #########################

Unless otherwise indicated, throughout this program
quantities are measured in the following units:

epoch_year and epoch_day are the epoch of the elset
angle         radians
length        equatorial earth radii (1 unit = xkmper km)

South latitudes are negative.
East longitude is positive, west negative.
*/

/*########################### STRUCTURES ###########################*/

/* rectangular coordinates */

struct vector { double x, y, z; };


/*########################### GLOBAL DATA ###########################*/

/* Set by getsites */
CLASS int out;
CLASS int num_sites;
CLASS int sitenum[MAXSITES];
CLASS char siteabbr[MAXSITES][4];
CLASS double xlat[MAXSITES], xlong[MAXSITES], xhgt[MAXSITES];

/* Satellite name */
CLASS char sat_name[81];
CLASS char sat_desig[9];

CLASS long sat_ncat;  /* NORAD number */
CLASS int epoch_year;  /* epoch year */

/* satellite's orbital elements */
CLASS double
   qmo,   /* quasi mean anomaly (omegao + xmo) */
   xmo,   /* mean anomaly */
   xnodeo,   /* right ascension of ascending node */
   omegao,   /* argument of the perigee */
   eo,   /* eccentricity */
   xincl,   /* inclination */
   xno,   /* mean motion, radians/min */
   xndt2o,   /* 1st time derivative of mean motion */
   bstar,   /* BSTAR drag term */
   epoch_day,   /* epoch day of elements */
   max_obs_day;

/* matrix */
CLASS double
   oldrms,
   newrms;

/* Satellite geocentric position and velocity.  Generated by the
prediction model. */
CLASS struct vector sat, satdot;

CLASS unsigned
   n,   /* number of observed quantities (3 per observation) */
   p,   /* number of elements to correct */
   nobs;   /* number of observations */

CLASS double
   tobs[MAXOBS]; /* epoch of observation */

CLASS struct vector
   place[MAXOBS];  /* observer x,y,z values at the time of this observation */

CLASS struct vector
   obs[MAXOBS];    /* array of observed (x,y,z) positions */

CLASS double
   W[MAXOBS]; /* array of weights to apply to observations (not implemented) */

CLASS struct vector
   b[MAXOBS];      /* array of residuals */

CLASS char label[MAXOBS][LBLLEN+1];   /* observation labels */

CLASS double
   *PX2P,    /* p x 2p matrix */
   *ATW,     /* p x (n+1) matrix */
   *AT;      /* row from ATW, with weighting removed */

/* Instead of manipulating the orbital elements directly, we use indirection
via elarr[] and elmod[].  Although more complex, it allows us to select at
run time which elements to refine. */

struct elemen {
   double *elp;    /* ptr to orbital element */
   double *conv;   /* conversion factor (deg to radians etc.) */
   char *elname;   /* name of the element */
   char *prnstr;   /* string to control format of printout */
};

CLASS struct elemen elarr[]
#ifdef MAIN
 = {
   {&qmo, &de2ra, "quasi mean anomaly", " [%.4f"},
   {&xno, &nocon, "mean motion", " [%.8f"},
   {&bstar, &one, "BSTAR", " [%.4e"},
   {&xincl, &de2ra, "inclination", " [%.4f"},
   {&xnodeo, &de2ra, "R.A. Asc. Node", " [%.4f"},
   {&eo, &one, "eccentricity", " [%.7f"},
   {&omegao, &de2ra, "arg of perigee", " [%.4f"}
}
#endif
;

CLASS double delel[NUMEL]   /* defaults for deltas in deriv() */
#ifdef MAIN
 = {0.0400 * 0.01745, 0.000020 / 458.0, 0.000005, 0.0050 * 0.01745,
    0.0050 * 0.01745, 0.0002000, 0.0400 * 0.01745}
#endif
;

CLASS unsigned tomod[8];   /* indicates the members of elarr[]
            we want to adjust */

/* input buffer, pointer to tokens in buf[] */
CLASS char buf[81], **tokp;
CLASS char line1[81], line2[81];

/* Sin & cos of epsilon, the obliquity of ecliptic.  Since epsilon
changes but .013 deg/century, it's sufficient to use a fixed value,
that of 1975 (23.442 deg). */

struct rotmat {
   double ix, jx, kx, iy, jy, ky, iz, jz, kz;
};

/* precession rotation matrix. */
CLASS struct rotmat depoch;


/*######################### Functions #########################*/


/* FILE elcor.c */

/* convert time string to minutes */
double atomin(char *string);

/* input element or delta element, with default */
void el_in(int u, struct elemen *elemp, double *dp, int *iflag);

/* returns argument modulo 2pi */
double fmod2p(double x);

/* date to Julian Date */
long int julday(int y, int m, int d);

/* input a string, with prompt */
char *s_in(char *prompt, char *buffer);

/* Greenwich hour angle of Aries */
double thetag(double ep);

/* tokenizes buf[], sets tokp. */
void tok(void);


/* FILE getsites.c */

void getsites(void);


/* FILE getobs.c */

/* loads tobs[], xyzobs[], W[], place[] with data from the observation file. */
void getobs(char *cp);


/* FILE getel.c */

/* inputs the orbital elements */
int getel(FILE *fp);

int cksum(char *line);


/* FILE matrix.c */

/* computes n x p array of partial derivatives, places it in ATW */
void deriv(int r);

/* least squares adjustment of orbital elements */
void lsqr();

/* compute & print residuals */
void prnres();


/* FILE sgp4.c */

/* orbit prediction model */
void sgp4(double tsince);
void sdp4(double jdi, double tsince);
void sxp4(double jdi, double tsince);

